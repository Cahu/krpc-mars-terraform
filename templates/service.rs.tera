{%- import "macros" as macros -%}
use krpc_mars::krpc as krpc;
use krpc_mars::codec as codec;
use krpc_mars::protobuf as protobuf;
use krpc_mars::RPCClient;
use krpc_mars::rpcfailure::RPCFailure;
use krpc_mars::codec::RPCEncodable;
use krpc_mars::codec::RPCExtractable;

use std::collections::HashSet;
use std::collections::HashMap;


#[derive(Clone)]
pub struct {{ service_name }} {
    client: RPCClient,
}

impl {{ service_name }} {
    pub fn new(client: RPCClient) -> Self {
        {{ service_name }} { client }
    }
}


{% for name, def in service_definition.classes %}
#[derive(Debug, Copy, Clone)]
pub struct {{ name }} (u32);

impl RPCEncodable for {{ name }} {
    fn encode(&self, output: &mut protobuf::CodedOutputStream) -> Result<(), protobuf::ProtobufError> {
        self.0.encode(output)
    }
}

impl RPCExtractable for {{ name }} {
    fn extract_value(input: &mut protobuf::CodedInputStream) -> Result<Self, protobuf::ProtobufError> {
        let value = RPCExtractable::extract_value(input)?;
        Ok({{ name }}(value))
    }
}
{% endfor %}

{% for name, def in service_definition.enumerations %}
#[derive(Debug, Copy, Clone)]
pub enum {{ name }} {
{%- for val_def in def.values %}
    {{ val_def.name }} = {{ val_def.value }},
{%- endfor %}
}

impl From<u32> for {{ name }} {
    #[inline]
    fn from(source: u32) -> Self {
        match source {
        {%- for val_def in def.values %}
            {{ val_def.value }} => {{ name }}::{{ val_def.name }},
        {%- endfor %}
            _ => panic!("Could not convert '{}' to a {{ service_name }}::{{ name }}", source),
        }
    }
}

impl RPCEncodable for {{ name }} {
    fn encode(&self, output: &mut protobuf::CodedOutputStream) -> Result<(), protobuf::ProtobufError> {
        (*self as u32).encode(output)
    }
}

impl RPCExtractable for {{ name }} {
    fn extract_value(input: &mut protobuf::CodedInputStream) -> Result<Self, protobuf::ProtobufError> {
        let value : u32 = RPCExtractable::extract_value(input)?;
        Ok({{ name }}::from(value))
    }
}
{% endfor %}

{% for proc_name, proc_def in service_definition.procedures %}
impl {{ service_name }} {
    {%- set_global param_list = "&self" %}
    {%- for param_def in proc_def.parameters %}
        {%- set        param_type = type_for(type=param_def.type) %}
        {%- set        param      = macros::format_parameter(name=param_def.name, type=param_type) %}
        {%- set_global param_list = macros::myjoin(sep=", ", strings=[param_list, param]) %}
    {%- endfor %}

    {%- set return_type = "()" %}
    {%- if proc_def.return_type is defined %}
        {%- set return_type = type_for(type=proc_def.return_type) %}
        {%- if proc_def.return_is_nullable %}
            {%- set return_type = macros::make_optional(type=return_type) %}
        {%- endif %}
    {%- endif %}
    pub fn {{ proc_name | lower }}({{ param_list }}) -> Result<{{ return_type }}, RPCFailure> {

        let mut proc_call = krpc::ProcedureCall::new();
        proc_call.set_service(String::from("{{ service_name }}"));
        proc_call.set_procedure(String::from("{{ proc_name }}"));

    {%- if proc_def.parameters | length > 0 %}

        let mut arguments = protobuf::RepeatedField::<krpc::Argument>::new();

        {%- for param_def in proc_def.parameters %}

        let mut arg{{ loop.index }} = krpc::Argument::new();
        arg{{ loop.index }}.set_position({{ loop.index0 }});
        arg{{ loop.index }}.set_value(p_{{ param_def.name }}.encode_to_bytes().unwrap());
        arguments.push(arg{{ loop.index }});
        {%- endfor %}
        proc_call.set_arguments(arguments);
    {%- endif %}

        let response = self.client.make_proc_call(proc_call)?;
    {%- if proc_def.return_is_nullable %}
        if response.results.len() > 0 {
            let value = codec::extract(&response.results[0])?;
            Ok(Some(value))
        }
        else {
            Ok(None)
        }
    {%- else %}
        let value = codec::extract(&response.results[0])?;
        Ok(value)
    {%- endif %}
    }
}
{% endfor %}
