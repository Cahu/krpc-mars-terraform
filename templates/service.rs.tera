{%- import "macros" as macros %}
use krpc;
use codec;
use super::*;

{% for name, def in service_definition.classes %}
struct {{ name }} (u32);

impl AsRef<u32> for {{ name }} {
    fn as_ref(&self) -> &u32 {
        &self.0
    }
}
{% endfor %}

{% for name, def in service_definition.enumerations %}
enum {{ name }} {
{%- for val_def in def.values %}
    {{ val_def.name }} = {{ val_def.value }},
{%- endfor %}
}

impl TryFrom<u32> for {{ name }} {
    type Error = String;
    #[inline]
    fn try_from(source: u32) -> Result<{{ name }}, String> {
        match source {
        {%- for val_def in def.values %}
            {{ val_def.value }} => Ok({{ name }}::{{ val_def.name }}),
        {%- endfor %}
            _ => Err(format!("Could not convert '{}' to a {{ service_name }}::{{ name }}", source)),
        }
    }
}
{% endfor %}

{% for proc_name, proc_def in service_definition.procedures %}

    {%- set_global param_list = "client: &mut RPCClient" %}
    {%- for param_def in proc_def.parameters %}
        {%- set        param_type = type_for(type=param_def.type) %}
        {%- set        param      = macros::format_parameter(name=param_def.name, type=param_type) %}
        {%- set_global param_list = macros::myjoin(sep=", ", strings=[param_list, param]) %}
    {%- endfor %}

    {%- if proc_def.return_type is defined %}
        {%- set return_type = type_for(type=proc_def.return_type) %}
        {%- if proc_def.return_is_nullable %}
            {%- set return_type = macros::make_optional(type=return_type) %}
        {%- endif %}
pub fn {{ proc_name | lower }}({{ param_list }}) -> {{ return_type }} {
    {%- else %}
pub fn {{ proc_name | lower }}({{ param_list }}) {
    {%- endif %}

    let mut proc_call = krpc::ProcedureCall::new();
    proc_call.set_service("{{ service_name }}");
    proc_call.set_procedure("{{ proc_name }}");

    {%- if proc_def.parameters | length > 0 %}

    let mut arguments = protobuf::RepeatedField<krpc::Argument>::new();

        {%- for param_def in proc_def.parameters %}

    let mut arg{{ loop.index }} = krpc::Argument::new();
    arg{{ loop.index }}.set_position({{ loop.index0 }});
    arg{{ loop.index }}.set_value(p_{{ param_def.name }}.encode_to_bytes().unwrap());
    arguments.push(arg{{ loop.index }});
        {%- endfor %}
    proc_call.set_arguments(arguments);
    {%- endif %}

    let response = client.make_proc_call(proc_call)?;
    let value    = codec::extract(&response.result)?;
    
    Ok(value)
}

{% endfor %}
}

{{ __tera_context }}
